import functools
import typing as t
from collections import abc as cabc

from mywerkzeug._internal import _wsgi_decoding_dance
from mywerkzeug.datastructures import EnvironHeaders
from mywerkzeug.datastructures import iter_multi_items
from mywerkzeug.wsgi import _get_server
from mywerkzeug.sansio.request import Request as _SansIORequest

if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment

class Request(_SansIORequest):
    """Represents an incoming WSGI HTTP request, with headers and body
    taken from the WSGI environment. Has properties and methods for
    using the functionality defined by various HTTP specs. The data in 
    request object is read-only.
    
    Text data is assumed to use UTF-8 encoding, which should be true for
    the vast majority of modern clients. Using an encoding set by the
    client is unsafe in Python due to extra encoding, subclass and replace
    attibute (charset).

    :param environ: Generated bye WSGI server and contains server config and 
        client request.
    :param populate_request: Add this request object to the WSGI environ as
        environ['werkzeug.request']. Can be useful when debugging.
    :param shallow: Makes reading from attribute (stream) (and any method that
        would read from it) raise a execpt.RuntimeError. Useful to prevent 
        consuming the form data in middleware, which would make it unavailable
        to the final application.

    .. versionchanged::
    3.0 - (charset), (url_charset), (encoding_errors) param was removed.
    2.1 - Old (BaseRequest) and mixin classes were removed.
    2.1 - Remove the (disable_data_descriptor) attribute.
    2.0 - Cobine (BaseRequest) and mixins into a single (Request) class.
    0.5 - Read-only mode is enforced with immutable classes for all data.
    """

    environ: WSGIEnvironment

    shallow: bool

    def __init__(
        self, 
        environ: WSGIEnvironment, 
        populate_request: bool = True,
        shallow: bool = False,
    ) -> None:
        super().__init__(
            method=environ.get("REQUEST_METHOD", "GET"),
            scheme=environ.get("wsgi.url_scheme", "http"),
            server=_get_server(environ),
            root_path=_wsgi_decoding_dance(environ.get("SCRIPT_NAME") or ""),
            path=_wsgi_decoding_dance(environ.get("PATH_INFO") or ""),
            query_string=environ.get("QUERY_STRING", "").encode("latin1"),
            headers=EnvironHeaders(environ),
            remote_addr=environ.get("REMOTE_ADDR")
        )
        self.environ = environ
        self.shallow = shallow

        if populate_request and not shallow:
            self.environ["werkzeug.request"] = self

    @classmethod
    def application(cls, f: t.Callable[[Request], WSGIApplication]) -> WSGIApplication:
        """Decorate a function as responder that accept the request as
        the last argument. This works like the function (responder)
        decorator but the function is passed the request object as the
        last argument and the request object will be closed automatically:: 
        
            @Request.application
            def my_wsgi_app(request):
                return Response('Hello World!')
        As of Werkzeug 0.14 HTTP exceptions are automatically caught and
        converted to responses instead of failing.
                
        :param f: the WSGI callable to decorate
        :return: a new WSGI callable
        """

        from mywerkzeug.exceptions import HTTPException

        @functools.wraps(f)
        def application(*args: t.Any) -> cabc.Iterable[bytes]:
            request = cls(args[-2])
            with request: # __enter__, __exit__
                try:
                    resp = f(*args[:-2] + (request,))
                except HTTPException as e:
                    resp = t.cast("WSGIApplication", e.get_response(args[-2]))
                return resp(*args[-2:])
        return t.cast("WSGIApplication", application)

    def close(self) -> None:
        """Closes associated resources of this request object. This
        closes all fine handles explicitly. You can also use the request
        object in a with statement which will automatically close it.
        
        .. versionadded:: 0.9 
        """
        files = self.__dict__.get("files")
        for _key, value in iter_multi_items(files or ()):
            value.close()

    def __enter__(self) -> Request:
        return self
    
    def __exit__(self, exc_type, exc_value, tb) -> None: #type: ignore
        self.close()